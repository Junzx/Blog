---
title: 中文共指消解问题研究
date: 2019-05-01 16:34:50
tags:
    - Coreference Resolution
    - NLP
top: 1
description: 从0构建指代消解系统

---
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>

## 目录

## 什么是指代？

**指代**（coreference）为语言学中为了避免已经出现的字词重复出现在文章的句子上，导致语句结构过于赘述和语意不够清晰，所以使用<u>代词</u>（pronouns）或是<u>名词</u>（nouns）来代替已经出现过的字词。

例子：

1. <font color="RED">特朗普</font>访问中国，这是<font color="RED">美国总统</font>第n次来华访问。
2. <font color="RED">小明</font>身长八尺，<font color="RED">他</font>学习成绩优异，深得老师同学们的喜欢。

**概念一：表述、实体**

在以上的例子中，<font color="RED">红色</font>字体标注的词语，我们称为**<font color="BLUE">表述</font>**，对应真实世界中的**<font color="BLUE">实体</font>**。

<font color="BLUE">表述</font>与<font color="BLUE">实体</font>是在指代消解问题中常见的术语。<font color="BLUE">实体（Entity）</font>是存在于客观世界的某种事物，是一种切实存在的概念。文本中会出现很多的名词短语以及代词，这些句子成分被称作<font color="BLUE">表述（Mention）</font>，是一个事物在文本中的一种体现。

>In coreference resolution, an entity is an object or set of objects in the world, while a mention is the textual reference to an entity (Doddington et al., 2004).

**概念二：指代、回指、共指**

指代关系按照表述是否依赖上下文可以分为回指和共指。我们通常讨论的指代关系主要是指**共指** ，即考虑表述之间是否指向同一个实体。在这个问题中，<u>回指</u>通常是针对代词而言，<u>是一种特殊的共指关系</u>。

**<font color="RED">因此</font>**，在下文中，我们可能会混用“<font color="RED">共指</font>”和“<font color="RED">指代</font>”两个描述方法，但是我们想表达的意思是相同的。

## 什么是指代消解？

**指代消解**即为文中的表述确定其在真实世界中所指向实体的过程.
>Coreference resolution, the task of identifying which mentions in a text refer to the same real world entity, is fundamentally a clustering problem.

指代消解任务通常分为两步：

- 第一步：表述提取，也称待消解项识别。即从文本中找到下一步任务中待处理的候选表述。
- 第二步：指代消解。对提取的候选表述集合进行分析处理，判断它们的指代结果。

## 为什么要研究指代消解？

- 在机器翻译问题中，对于代词'they'可以通过分析词语的指代关系翻译为“他们”或者“她们”，从而使翻译更加准确。
- 在文本摘要问题中，适当采用代词对某些词语进行替换，提升可读性。
- 在知识图谱领域中，可以参考指代消解的方法，将知识融合问题与消解问题类比，即对于同一实体的词语单元合并为同一个cluster
- 另外，文本理解是人工智能领域一个重要的技术难点。国务院在2017年发布的《新一代人工智能发展规划》中明确提出，要重点突破自然语言的语法逻辑以及深度语义分析的核心技术，将对中文文本的研究提高到国家战略层面。

结论：指代消解在实际的生产生活中有着广泛应用。

## 指代消解常见方法有哪些？

### 表述提取方法

### 指代消解方法

## 如何评价指代消解的效果？

<p>
<font color="RED">例</font>：给出标准的划分和结果划分。

<center>![image](/中文共指消解问题研究/3.JPG)</center>


	Label={a,b,c},{d,e},{f,g,h} 
	Resolution={a,b},{c,d,e},{f,g,i}
	其中abc表示一个表述，用大括号表示一个实体。处于同一个大括号的表述属于同一实体。

### MUC

- Precision:指消解后的结果中，正确处理的表述占实际处理的表述的百分比
- Recall:描述消解结果中正确处理的表述占数据集中所有待消解表述的百分比

$$Precision=\frac{\sum_{i}^{N_r}(|R_i|-p(R_i))}{\sum_{i}^{N_r}(|R_i|-1)}$$
$$Recall=\frac{\sum_{i}^{N_l}(|L_i|-p(L_i))}{\sum_{i}^{N_l}(|L_i|-1)}$$


其中\\(L_i\\)表示标记数据中第i个实体的情况，\\(R_i\\)表示消解结果中第\\(i\\)个实体。‘|’表示当前实体所包含的表述数量。计算准确率的公式中的\\(p(R_i\\)是指消解结果中第\\(i\\)个实体中实际包含了多少个真实的实体，其中没有出现在标记数据中的独立表述，我们认为它是独立的一个实体。计算召回率的公式中的\\(p(L_i)\\)是指标记数据中的第\\(i\\)个实体被划分为多少个子类。在下图中我们用实线椭圆表示标记数据的实体类，用虚线椭圆表示消解结果中的实体类。

<center>![image](/中文共指消解问题研究/4.JPG)</center>

有：
$$Precision=\frac{(2-1)+(3-2)+(3-2)}{(2-1)+(3-1)+(3-1)}=0.6$$
$$Recall=\frac{(3-2)+(2-1)+(3-2)}{(3-1)+(2-1)+(3-1)}=0.6$$

### BCUB

$$Precision=\frac{\sum_{i}^{N_l} \sum_{j}^{N_r}\frac{|{L_i}\cap{R_j}|^2}{|L_i|}}{\sum_{j}^{N_r}{|L_i|}}$$

$$Recall=\frac{\sum_{i}^{N_l} \sum_{j}^{N_r}\frac{|{L_i}\cap{R_j}|^2}{|R_j|}}{\sum_{j}^{N_r}{|R_j|}}$$

## 如何构建完整的指代消解系统

下图是一个基于多轮处理的指代消解系统的结构图。

<center>![image](/中文共指消解问题研究/系统结构图.png)</center>

处理步骤：

1. 预处理：首先对输入的文本进行预处理，完成一些基本的词性标注，构建句法树等工作。
2. 表述提取：然后将预处理好的数据传入表述提取部分，通过一定的方法获取候选表述。
3. 指代消解：接着将提取的待处理表述集合传递给指代消解部分，完成一个处理流过程。



### 表述提取

对文本进行基本处理，提取其中的名词短语。

### 基于多轮规则的指代消解

在指代消解部分中我们选择了下图中多个消解规则进行组合，构成多轮规则处理的指代消解系统。其中每一轮我们使用一个消解规则。

<center><img src="/中文共指消解问题研究/系统概述-规则.jpg" width="50%" height="50%"></center>
	
对于单个规则我们采用如下的方法进行处理：

<center>![image](/中文共指消解问题研究/规则-单个规则流程图.jpg)</center>

举例进行解释，假设我们有candidate_mentions\\(=[m_1, m_2, m_3, m_4, m_5, m_6, m_7]\\)个表述，我们的处理方式为：

	for mention in candiate_mentions: # 从m_2开始，每次选择一个
		候选表述list = get_candidate(mention)	# 选择mention前面的表述作为候选集合
		for 候选表述 in 候选表述list：				# 从候选表述中选择一个表述
			if 候选表述 coref with mention: 		# 如果这个候选与mention共指
				set_coref(候选表述，mention)
				break							# 如果找到了，那么则停止判断

#### 1. 字符串匹配规则

如果两个候选表述的<u>修饰语</u>和<u>限定词</u>相同，且两个表述<u>文本</u>相同，那么这两个表述存在指代关系。

设计意义:

1. 约束修饰语和限定词

	考察句子
	
		小明的老师在闲暇时也会教小李，这也给小李的老师减轻了工作负担。
	
	其中包含的表述有
	
		{小明的老师，小明，老师，小李的老师，小李，老师}
	
	我们可以看到在表述集合中有两个<u>文本内容</u>完全相同的表述**“老师”**，但是这两个表述并不指代同一人。对于第一个表述“老师”而言，它的修饰语为<u>“小明的”</u>，对于第二个表述“老师”而言，它的修饰语为<u>“小李的”</u>。虽然表述的文本内容相同，但是因为修饰语不相同，所以这两个表述不存在指代关系。

2. 约束文本相同
	
	考察两个表述：

		“凳子”、“茶具”
	
	词语“凳子”、“茶具”作为表述它们是独立的词语，但是在文本中他们仍然可能存在修饰成分。
	
	例如由**“这精美的”**构成名词短语
	
		“这精美的凳子”、“这精美的茶具”
	
	可以很清楚的看到，这两个表述具有相同的修饰语和限定词，但是它们本身就是不同的事物。

#### 2. 词语结构匹配规则

针对表述之间所处的位置关系和句子中扮演的角色进行分析。设计了以下的约束条件，如果满足其中某一种条件，那么两个表述之间存在指代关系。

1. 同位语关系

	同位语是指一个短语对它周围的某个名词或者代词起到补充解释的作用，并且空间距离相近，语义相关。

	例如：
	
		小明，三年二班的班长。

2. 谓语主格

	谓语主格是指句子中“<u>句子成分1</u>+**是**+<u>句子成分2</u>”结构的表达方式，通常句子成分2作为成分1的补充说明。

	例如：

		“在学术研讨会上，人们提出人工智能是社会新的发展方向”。
	
	这其中<u>“人工智能”</u>和<u>“社会新的发展方向”</u>就处于由**“是”**进行连接的谓语主格结构中。

3. 缩写关系
	
	例如
	
		“美联储”、“美国联邦储备局”
	
	生成缩写的方法：
	
		“中国篮球协会”→“中国/篮球/协会”→“中篮联”

#### 3. 中心词严格匹配规则

**中心词**是指短语中能够简单概括短语含义的部分。例如“北京大学”，其中心词就是<u>大学</u>；“中华人民共和国教育部”，其中心词则为<u>“教育部”</u>。

在这部分内容中，我们设定了**4个约束条件**，然后组合形成了**3个策略**。

##### 约束条件

**约束条件1：** 表述中心词是否出现在候选表述的中心词集合中

	输入：待处理的表述为m_i；候选表述集合C={m_1,m_2…,m_(i-1)}
	过程：
	1:	根据当时的指代情况对候选表述进行实体类的划分，得到E={E_j,j≤i-1}
	2:	找到m_i对应的中心词h_i
	3:	for m_j∈C:
	4:		选择m_j对应的E_j
	5:		对于E_j中的表述找到对应的中心词构成集合H'_j
	6:		if h_i in H'_j
	7:			True
	8:		else
	9:			False
	10:		end if
	11:	end for
	
	输出：是否满足这项约束



举例进行说明：

<center><img src="/中文共指消解问题研究/严格中心词匹配-1.jpg" width="50%" height="50%"></center>

图中的弧线表示两个表述存在指代关系。假设我们待处理的表述为\\(m_6\\)，根据规则我们选择出现在它前面的表述作为候选表述集合\\(C={m_1,m_2,m_3,m_4,m_5}\\)。对\\(m_6\\)找先行词的过程即是然后依次对\\(m_i\in{C}\\)与\\(m_6\\)进行判断。在当前的时刻，我们已知\\(m_1\\)与\\(m_7\\)共指，\\(m_2\\)与\\(m_3\\)共指。

对于集合C中的表述，我们可以得到候选表述中实体类的划分E={\\(E_1=(m_1,m_7 ),E_2=(m_2,m_3 ),E_3=(m_4 ),E_4=(m_5)\\)}。因此可以得到每个实体类对应的中心词集合，得到\\(H'={(h'_1,h'_7 ),(h'_2,h'_3 ),(h'_4 ),(h'_5 )}\\)。

因此，考察\\(m_6\\)和\\(m_1\\)是否指代使用此算法即使求\\(h_6\\)是否包含在\\(H'_1=(h'_1,h'_7)\\)中；对\\(m_6\\)和\\(m_2\\)使用此算法即使求\\(h_6\\)是否包含在\\(H'_2=(h'_2,h'_3)\\)中；对其他的候选表述使用类似的操作。

用实际的例子进一步进行讲解。

假设处理表述**“上海”**，它的中心词即为它<u>本身</u>。

它对应的<u>候选表述</u>有：
	
	{中国上海；一个发达的城市}。

根据<u>现有的指代情况</u>有：

	{“中国上海”：(中国上海，沪)，“一个发达的城市”： (一个发达的城市)}

因此可以得到的<u>中心词集合</u>：

	{（上海，沪），（城市）}

当我们对“上海”和候选表述“中国上海”进行判别时，我们将考察“上海”的中心词是否在（上海，沪）中。

当我们对“上海”和候选表述“一个发达的城市”判别时，我们将考察“上海”的中心词是否在（城市）中。

**约束条件2:** 非停用字包含

在这项约束中，我们要求表述所包含的没有出现在停用词集合中的字，必须包含在由候选表述的中未出现在停用词的字构成的集合中。

在项目中，我们维护了一个常用停用词列表。假设有停用词词表S，现有待处理的表述\\(m_i\\)和它的候选表述\\(c_i\\)，其中\\(m_i=(w_1,w_2,…,w_n ),c_i=(w'_1,w'_2,…,w'_n )\\)，w和w'分别表示构成表述的单字。因此对于表述m_i，我们求取它和S的差集，并将结果定义为S'。对于候选表述\\(c_i\\)求取它和S的差集并将结果定义为S''。那么如果\\(S'\subseteq{S''}\\)，那么我们认为满足此项约束。

例如考察表述：

	“一个发展中的城市”、“沿海地区一个经济发达的城市”

删除表述和候选表述中停用词后，得到的集合存在包含关系，因此<u>满足</u>此项约束。

而对于表述：

	“一个发展中的城市”、“沿海地区一个发达的城市”

这两个表述虽然具有相同的中心词，但是除去停用词后产生的集合不满足包含的关系，因此<u>不满足</u>此项约束。

**约束条件3：**表述修饰语是否出现在候选表述修饰语中

如果当前待处理的表述的修饰语包含在候选表述的修饰语中，则满足此项约束。

例如考察表述：

	发达的上海

以及它的候选表述：
	
	一个发达的城市

我们可以得到候选表述修饰语 <u>“发达”</u>，因此表述“发达的上海”的修饰语包含在候选表述的修饰语中，两个表述满足此项约束。

**约束条件4：**表述间是否存在子结构

将考察两个表述是否具有互相包含的关系

##### 策略

**策略1：**中心词严格匹配——严格策略

条件 | 值 |
:-:|:-:|
当前表述与其候选表述是否存在相同中心词 | True
表述中心词是否出现在候选表述的中心词集合中 | True
是否满足非停用字包含条件 | True
表述修饰语是否出现在候选表述修饰语中 | True
表述间是否存在子结构 | False


**策略2：**中心词严格匹配——中间策略


条件 | 值 |
:-:|:-:|
当前表述与其候选表述是否存在相同中心词 | True
表述中心词是否出现在候选表述的中心词集合中 | True
是否满足非停用字包含条件 | True
表述间是否存在子结构 | False


**策略3：**中心词严格匹配——宽松策略


条件 | 值 |
:-:|:-:|
当前表述与其候选表述是否存在相同中心词 | True
表述中心词是否出现在候选表述的中心词集合中 | True
表述修饰语是否出现在候选表述修饰语中 | True
表述间是否存在子结构 | False


#### 4.中心词宽松匹配规则

条件 | 值
:-:|:-:|
表述中心词是否包含于候选表述中心词集合中 | True
表述和候选表述是否具有相同的命名实体标签 | True
是否满足非停用字包含条件 | True
表述间是否存在子结构 | False


#### 5. 专有名词中心词匹配规则

条件 | 值
:-:|:-:|
是否均被标记为命名实体 | True
是否有相同的命名实体标签 | True
待处理表述中的数量词是否在出现候选表述中 | True
表述间是否存在子结构 | False

#### 6. 第一二人称代词消解规则

pass

#### 7. 第三人称代词消解规则

pass

#### 8. 语义规则

pass